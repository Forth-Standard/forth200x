<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><script src="//archive.org/includes/analytics.js?v=cf34f82" type="text/javascript"></script>
<script type="text/javascript">window.addEventListener('DOMContentLoaded',function(){var v=archive_analytics.values;v.service='wb';v.server_name='wwwb-app103.us.archive.org';v.server_ms=874;archive_analytics.send_pageview({});});</script><script type="text/javascript" src="/_static/js/playback.bundle.js?v=qchdzUCo" charset="utf-8"></script>
<script type="text/javascript" src="/_static/js/wombat.js?v=cRqOKCOw" charset="utf-8"></script>
<script type="text/javascript">
  __wm.init("https://web.archive.org/web");
  __wm.wombat("http://amforth.sourceforge.net/pr/Recognizer-rfc.html","20160328150143","https://web.archive.org/web/","web","/_static/",
	      "1459177303","amforth.sourceforge.net");
</script>
<link rel="stylesheet" type="text/css" href="/_static/css/banner-styles.css?v=NHuXCfBH" />
<link rel="stylesheet" type="text/css" href="/_static/css/iconochive.css?v=qtvMKcIJ" />
<!-- End Wayback Rewrite JS Include -->

<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<meta name="generator" content="Docutils 0.11: http://docutils.sourceforge.net/"/>
<title>Forth Recognizer -- Request For Discussion</title>
<meta name="author" content="Matthias Trute"/>
<meta name="date" content="3.10.2014"/>
<style type="text/css">

/*
:Author: David Goodger (goodger@python.org)
:Id: $Id: html4css1.css 7614 2013-02-21 15:55:51Z milde $
:Copyright: This stylesheet has been placed in the public domain.

Default cascading style sheet for the HTML output of Docutils.

See http://docutils.sf.net/docs/howto/html-stylesheets.html for how to
customize this style sheet.
*/

/* used to remove borders from tables and images */
.borderless, table.borderless td, table.borderless th {
  border: 0 }

table.borderless td, table.borderless th {
  /* Override padding for "table.docutils td" with "! important".
     The right padding separates the table cells. */
  padding: 0 0.5em 0 0 ! important }

.first {
  /* Override more specific margin styles with "! important". */
  margin-top: 0 ! important }

.last, .with-subtitle {
  margin-bottom: 0 ! important }

.hidden {
  display: none }

a.toc-backref {
  text-decoration: none ;
  color: black }

blockquote.epigraph {
  margin: 2em 5em ; }

dl.docutils dd {
  margin-bottom: 0.5em }

object[type="image/svg+xml"], object[type="application/x-shockwave-flash"] {
  overflow: hidden;
}

/* Uncomment (and remove this text!) to get bold-faced definition list terms
dl.docutils dt {
  font-weight: bold }
*/

div.abstract {
  margin: 2em 5em }

div.abstract p.topic-title {
  font-weight: bold ;
  text-align: center }

div.admonition, div.attention, div.caution, div.danger, div.error,
div.hint, div.important, div.note, div.tip, div.warning {
  margin: 2em ;
  border: medium outset ;
  padding: 1em }

div.admonition p.admonition-title, div.hint p.admonition-title,
div.important p.admonition-title, div.note p.admonition-title,
div.tip p.admonition-title {
  font-weight: bold ;
  font-family: sans-serif }

div.attention p.admonition-title, div.caution p.admonition-title,
div.danger p.admonition-title, div.error p.admonition-title,
div.warning p.admonition-title, .code .error {
  color: red ;
  font-weight: bold ;
  font-family: sans-serif }

/* Uncomment (and remove this text!) to get reduced vertical space in
   compound paragraphs.
div.compound .compound-first, div.compound .compound-middle {
  margin-bottom: 0.5em }

div.compound .compound-last, div.compound .compound-middle {
  margin-top: 0.5em }
*/

div.dedication {
  margin: 2em 5em ;
  text-align: center ;
  font-style: italic }

div.dedication p.topic-title {
  font-weight: bold ;
  font-style: normal }

div.figure {
  margin-left: 2em ;
  margin-right: 2em }

div.footer, div.header {
  clear: both;
  font-size: smaller }

div.line-block {
  display: block ;
  margin-top: 1em ;
  margin-bottom: 1em }

div.line-block div.line-block {
  margin-top: 0 ;
  margin-bottom: 0 ;
  margin-left: 1.5em }

div.sidebar {
  margin: 0 0 0.5em 1em ;
  border: medium outset ;
  padding: 1em ;
  background-color: #ffffee ;
  width: 40% ;
  float: right ;
  clear: right }

div.sidebar p.rubric {
  font-family: sans-serif ;
  font-size: medium }

div.system-messages {
  margin: 5em }

div.system-messages h1 {
  color: red }

div.system-message {
  border: medium outset ;
  padding: 1em }

div.system-message p.system-message-title {
  color: red ;
  font-weight: bold }

div.topic {
  margin: 2em }

h1.section-subtitle, h2.section-subtitle, h3.section-subtitle,
h4.section-subtitle, h5.section-subtitle, h6.section-subtitle {
  margin-top: 0.4em }

h1.title {
  text-align: center }

h2.subtitle {
  text-align: center }

hr.docutils {
  width: 75% }

img.align-left, .figure.align-left, object.align-left {
  clear: left ;
  float: left ;
  margin-right: 1em }

img.align-right, .figure.align-right, object.align-right {
  clear: right ;
  float: right ;
  margin-left: 1em }

img.align-center, .figure.align-center, object.align-center {
  display: block;
  margin-left: auto;
  margin-right: auto;
}

.align-left {
  text-align: left }

.align-center {
  clear: both ;
  text-align: center }

.align-right {
  text-align: right }

/* reset inner alignment in figures */
div.align-right {
  text-align: inherit }

/* div.align-center * { */
/*   text-align: left } */

ol.simple, ul.simple {
  margin-bottom: 1em }

ol.arabic {
  list-style: decimal }

ol.loweralpha {
  list-style: lower-alpha }

ol.upperalpha {
  list-style: upper-alpha }

ol.lowerroman {
  list-style: lower-roman }

ol.upperroman {
  list-style: upper-roman }

p.attribution {
  text-align: right ;
  margin-left: 50% }

p.caption {
  font-style: italic }

p.credits {
  font-style: italic ;
  font-size: smaller }

p.label {
  white-space: nowrap }

p.rubric {
  font-weight: bold ;
  font-size: larger ;
  color: maroon ;
  text-align: center }

p.sidebar-title {
  font-family: sans-serif ;
  font-weight: bold ;
  font-size: larger }

p.sidebar-subtitle {
  font-family: sans-serif ;
  font-weight: bold }

p.topic-title {
  font-weight: bold }

pre.address {
  margin-bottom: 0 ;
  margin-top: 0 ;
  font: inherit }

pre.literal-block, pre.doctest-block, pre.math, pre.code {
  margin-left: 2em ;
  margin-right: 2em }

pre.code .ln { color: grey; } /* line numbers */
pre.code, code { background-color: #eeeeee }
pre.code .comment, code .comment { color: #5C6576 }
pre.code .keyword, code .keyword { color: #3B0D06; font-weight: bold }
pre.code .literal.string, code .literal.string { color: #0C5404 }
pre.code .name.builtin, code .name.builtin { color: #352B84 }
pre.code .deleted, code .deleted { background-color: #DEB0A1}
pre.code .inserted, code .inserted { background-color: #A3D289}

span.classifier {
  font-family: sans-serif ;
  font-style: oblique }

span.classifier-delimiter {
  font-family: sans-serif ;
  font-weight: bold }

span.interpreted {
  font-family: sans-serif }

span.option {
  white-space: nowrap }

span.pre {
  white-space: pre }

span.problematic {
  color: red }

span.section-subtitle {
  /* font-size relative to parent (h1..h6 element) */
  font-size: 80% }

table.citation {
  border-left: solid 1px gray;
  margin-left: 1px }

table.docinfo {
  margin: 2em 4em }

table.docutils {
  margin-top: 0.5em ;
  margin-bottom: 0.5em }

table.footnote {
  border-left: solid 1px black;
  margin-left: 1px }

table.docutils td, table.docutils th,
table.docinfo td, table.docinfo th {
  padding-left: 0.5em ;
  padding-right: 0.5em ;
  vertical-align: top }

table.docutils th.field-name, table.docinfo th.docinfo-name {
  font-weight: bold ;
  text-align: left ;
  white-space: nowrap ;
  padding-left: 0 }

/* "booktabs" style (no vertical lines) */
table.docutils.booktabs {
  border: 0px;
  border-top: 2px solid;
  border-bottom: 2px solid;
  border-collapse: collapse;
}
table.docutils.booktabs * {
  border: 0px;
}
table.docutils.booktabs th {
  border-bottom: thin solid;
  text-align: left;
}

h1 tt.docutils, h2 tt.docutils, h3 tt.docutils,
h4 tt.docutils, h5 tt.docutils, h6 tt.docutils {
  font-size: 100% }

ul.auto-toc {
  list-style-type: none }

</style>
</head>
<body>
<div class="document" id="forth-recognizer-request-for-discussion">
<h1 class="title">Forth Recognizer -- Request For Discussion</h1>
<table class="docinfo" frame="void" rules="none">
<col class="docinfo-name"/>
<col class="docinfo-content"/>
<tbody valign="top">
<tr><th class="docinfo-name">Author:</th>
<td>Matthias Trute</td></tr>
<tr><th class="docinfo-name">Contact:</th>
<td><a class="first last reference external" href="https://web.archive.org/web/20160328150143/mailto:mtrute@web.de">mtrute&#64;web.de</a></td></tr>
<tr><th class="docinfo-name">Version:</th>
<td>1</td></tr>
<tr><th class="docinfo-name">Date:</th>
<td>3.10.2014</td></tr>
<tr><th class="docinfo-name">Status:</th>
<td>Final</td></tr>
</tbody>
</table>
<div class="section" id="background">
<h1>Background</h1>
<p>I'm working on a Forth for 8-bit micro-controllers
for 8 years now (<a class="reference external" href="https://web.archive.org/web/20160328150143/http://amforth.sf.net/">amforth.sf.net</a>).
It is not only a useful tool for serious work but
a nice playground to experiment with Forth too.</p>
<p>In 2011 my Forth got a floating point library. Since
a micro-controller is (was) a resource constrained
system it is not an option to include it permanently.
It has to be a loadable module. Therefore I needed a
way to keep the core system small but at the same time
able to fully handle the new numbers. All but one
problem were easy to fix. Only adding the number format
to the Forth interpreter turned out to be serious one. I
searched the net for ways to extend the Forth interpreter.
What I found was having many hooks in the interpreter (U.
Hoffman, Euroforth 2008) or a conditional re-compile of
the sources with an autotool/configure like build system.
Nothing really convinced me or my users. While googling
I stumbled across the number parsing prefix discussion
in c.l.f in 2007. The ideas sketched there looked
promising so I stopped searching and started with
them to invent my own solution.</p>
<p>I changed the Forth interpreter into a dumb tool, that
delegates all data related work to modules, which can
be changed at run-time. That made it possible to load the
FP library into a running system that afterwards was able
to deal with the new numbers like native ones. Surprisingly
the new system had no disadvantages in speed or size
compared the old one, something I consider very
important on a micro-controller.</p>
<p>Shortly thereafter, Bernd Paysan got interested in what I
did (we have regular IRC sessions on Forth topics) and
started to implement recognizers in gforth. He suggested
changes that further simplified my concept and made
it more flexible.</p>
<p>By now we reached a point that justifies the public review.
There are two very different Forth's available (both GPL'ed)
that implement recognizers. A third implementation is in
the proposal (public domain).</p>
<p>A recognizer written for one Forth works without modification
for the other ones too. The words used to actually implement a
recognizer (mostly string processing) need to be available
of course. E.g. I wrote a recognizer for time stamp strings
with gforth that converts the hh:mm:ss notation into a
double cell number for the seconds since midnight. The
code runs on amforth too. Gforth is a 64-bit system
on the PC, amforth a 16-bit system on an 8-bit micro-controller
(hence the double numbers). With that, something like</p>
<pre class="code forth literal-block">
<span class="keyword namespace">:</span> <span class="name class">test</span> <span class="literal number integer">01</span><span class="name function">:00:01</span> <span class="keyword">d. </span><span class="literal string">.&quot;</span> <span class="literal string"> seconds since midnight</span><span class="name function">&quot;</span> <span class="keyword">; </span><span class="name function">ok</span>
<span class="name function">test</span> <span class="literal number integer">3601</span> <span class="name function">seconds</span> <span class="name function">since</span> <span class="name function">midnight</span> <span class="name function">ok</span>
<span class="literal number integer">01</span><span class="name function">:01:00</span> <span class="literal number integer">01</span><span class="name function">:00:01</span> <span class="keyword">d+ d. </span><span class="literal number integer">7261</span> <span class="name function">ok</span>
</pre>
<p>is possible. Similarly strings: everything that starts
with a <tt class="docutils literal">&quot;</tt> is a string until the closing <tt class="docutils literal">&quot;</tt> is
reached. Further string handling get the addr/len
without the enclosing <tt class="docutils literal">&quot;</tt>.</p>
<pre class="code forth literal-block">
<span class="keyword namespace">:</span> <span class="name class">test</span> <span class="name function">&quot;A</span> <span class="name function">string&quot;</span> <span class="keyword">type ; </span><span class="name function">ok</span>
<span class="name function">test</span> <span class="name function">A</span> <span class="name function">string</span> <span class="name function">ok</span>
<span class="name function">&quot;</span> <span class="name function">Another</span> <span class="name function">string&quot;</span> <span class="keyword">type </span><span class="name function">ok</span>  <span class="name function">Another</span> <span class="name function">string</span>
</pre>
<p>Another use case are name-spaces with
word lists, without touching <tt class="docutils literal">ORDER</tt>:</p>
<pre class="code forth literal-block">
<span class="keyword namespace">:</span> <span class="name class">test</span> <span class="name function">i2c.begin</span> <span class="name function">i2c.sendbyte</span> <span class="name function">i2c.end</span> <span class="keyword">;</span>
</pre>
<p>where <tt class="docutils literal">begin/sendbyte/end</tt> are words from
the word-list identified with <tt class="docutils literal">i2c</tt> (a constant
with the wid). The recognizer splits the word
at the first dot and uses the left sub-word to
get the a word-list. In that word-list it searches
with the remaining string and handles the result
just like an ordinary dictionary search:
interpret, compile (or not found).</p>
<p>Implementations for these examples are available in
the respective Forth systems.</p>
</div>
<div class="section" id="problem">
<h1>Problem</h1>
<p>The Forth compiler can be extended easily. The Forth
interpreter however has a fixed set of capabilities as
outlined in section 3.4 of the standard text: Words from
the dictionary and some numbers.</p>
<p>It's not easily possible to use the Forth text interpreter
in an application or system extension context. The building
blocks (<tt class="docutils literal">FIND</tt>, <tt class="docutils literal">COMPILE,</tt>, <tt class="docutils literal">&gt;NUMBER</tt> etc) are available
but there is a gap between them and what the Forth interpreter
does. Applications need to use either additional system
provided and system specific intermediate words (if available)
or have to re-invent the wheel to use e.g. numbers with a
sign or hex numbers with the $ prefix.</p>
<p>Some Forth interpreters have ways to add new data types.
That makes it possible to use a loadable library to
implement new data types to be handled like the built-in
ones. An example are the floating point numbers. They
have their own parsing and data handling words including
a stack of their own.</p>
<p>To actually handle data in the Forth context, the
processing actions need to be <tt class="docutils literal">STATE</tt> aware. It
would be nice if the Forth text interpreter,
that maintains <tt class="docutils literal">STATE</tt>, is able to do the data
processing without exposing <tt class="docutils literal">STATE</tt> to the data
handling methods. For that the different methods
need to be registered somehow.</p>
<p>Whenever the Forth text interpreter is mentioned, the standard
words <tt class="docutils literal">EVALUATE</tt> (CORE), <tt class="docutils literal"><span class="pre">INCLUDE-FILE</span></tt> (FILE), <tt class="docutils literal">INCLUDED</tt>
(FILE), <tt class="docutils literal">LOAD</tt> (BLOCK) and <tt class="docutils literal">THRU</tt> (BLOCK) are expected to
act likewise.</p>
</div>
<div class="section" id="solution">
<h1>Solution</h1>
<p>The monolithic design of the Forth interpreter is factored into
three major blocks: First the interpreter. It maintains <tt class="docutils literal">STATE</tt>
and organizes the work. Second the actual data parsing. It is
called from the interpreter and analyses strings (usually
sub-strings of <tt class="docutils literal">SOURCE</tt>) if they match the criteria for a
certain data type. These parsing words are grouped as a stack
to achieve an order of invocation. The result of the parsing
words is handed over by the interpreter to data specific
handling methods. There are three different methods for each
data type depending on <tt class="docutils literal">STATE</tt> and to <tt class="docutils literal">POSTPONE</tt> the data.</p>
<p>The combination of a parsing word and the set of data handling words
to deal with the data is called a recognizer. There is no strict 1:1
relation between the parsing words and the data handling sets. A data
handling set for e.g. single cell numbers can be used by different
parsing words.</p>
</div>
<div class="section" id="proposal">
<h1>Proposal</h1>
<div class="section" id="xy-the-optional-recognizer-word-set">
<h2>XY. The optional Recognizer word set</h2>
<div class="section" id="xy-1-introduction">
<h3>XY.1 Introduction</h3>
<p>The algorithm of the Forth text interpreter as described in section
3.4 is modified as follows. All subsections of 3.4 apply unchanged.</p>
<ol class="loweralpha">
<li><p class="first">Skip leading spaces and parse a name. Leave if the parsing area
is empty.</p>
</li>
<li><p class="first">For each element of the recognizer stack, starting with the
top element, call its parsing method with the sub-string &quot;name&quot;
from step a).</p>
<p>Every parsing method returns an information token and the
parsed data from the analyzed sub-string if successful. Otherwise
it returns the system provided failure token <tt class="docutils literal">R:FAIL</tt> and no
further data.</p>
<p>Continue with the next element in the recognizer stack until
either all are used or the information token returned
from the parsing word is not the system provided failure token
<tt class="docutils literal">R:FAIL</tt>.</p>
</li>
<li><p class="first">Use the information token and do one of the following</p>
<ol class="arabic simple">
<li>if interpreting execute the interpret method associated with
the information token.</li>
<li>if compiling execute the compile method associated with the
information token.</li>
</ol>
</li>
<li><p class="first">Continue with a)</p>
</li>
</ol>
<p>A recognizer consists of two elements: a parsing word (<tt class="docutils literal">REC:FOO</tt>) and
one or more information tokens returned by the parsing words that identify
the parsed data and provide methods to perform the various semantics of
the data (interpret, compile and postpone). A parsing word can return
different information tokens. A particular information token can be used
by different parsing words.</p>
<p>There is a system provided information token called <tt class="docutils literal">R:FAIL</tt>. It is used
if no other token is applicable. This failure token is associated with
the system error actions if used in step c).</p>
<p>The parsing word of a recognizer has the stack effect</p>
<pre class="code forth literal-block">
<span class="name function">REC:FOO</span> <span class="comment single">( addr len -- i*x R:FOO | R:FAIL )</span>
</pre>
<p>&quot;addr/len&quot; is a sub-string provided by the Forth text interpreter
inside <tt class="docutils literal">SOURCE</tt>. The parsing word must not change the string
content. It can change <tt class="docutils literal">&gt;IN</tt> however.</p>
<p>&quot;i*x&quot; is the result of the text parsing of the string found
at &quot;addr/len&quot;. <tt class="docutils literal">R:FOO</tt> is the information token that the
interpreter uses to execute the interpret, compile or postpone
actions for the data &quot;i*x&quot;.</p>
<p>All three methods are called with the &quot;i*x&quot; data as left by the
parsing word.</p>
<pre class="code forth literal-block">
<span class="name function">R:FOO:METHOD</span> <span class="comment single">( ... i*x -- j*y )</span>
</pre>
<p>They can have additional stack effects, depending on what
<tt class="docutils literal">R:FOO:METHOS</tt> actually does.</p>
<p>The data items &quot;i*x&quot; don't have to be on the data stack, they
can be at different places, when applicable. E.g. floating
point numbers have a stack of their own. In this case,
the data stack contains the <tt class="docutils literal">R:FOO</tt> information only.</p>
<p>The names <tt class="docutils literal">R:FOO</tt>, <tt class="docutils literal">REC:FOO</tt> and <tt class="docutils literal">R:FOO:METHOD</tt>
don't have to actually exist, except the <tt class="docutils literal">R:FAIL</tt> name.</p>
<p>A Forth system shall provide recognizers for integer numbers (both
single and double precision) and the word look-up in the dictionary.
They shall be ordered in a way that the word look-up is called first
followed by the one(s) for numbers.</p>
<p>There shall be at least 4 recognizer slots available for
application use.</p>
</div>
<div class="section" id="xy-2-additional-terms-and-notations">
<h3>XY.2 Additional terms and notations</h3>
<p>Information token: A single cell number. It identifies the
data type and a method table to perform the data processing
of the interpreter. A naming convention suggests that the
names start with <tt class="docutils literal">R:</tt>.</p>
<p>Recognizer: A combination of a text parsing word that
returns information tokens together with parsed data
if successful. The text parsing word is assumed to
run in cooperation with <tt class="docutils literal">SOURCE</tt> and <tt class="docutils literal">&gt;IN</tt>. A
naming convention suggests that the names start
with <tt class="docutils literal">REC:</tt>.</p>
</div>
<div class="section" id="xy-3-additional-usage-requirements">
<h3>XY.3 Additional usage requirements</h3>
<div class="section" id="xy-3-1-environment-queries">
<h4>XY.3.1 Environment Queries</h4>
<p>Obsolete.</p>
</div>
</div>
<div class="section" id="xy-4-additional-documentation-requirements">
<h3>XY.4 Additional documentation requirements</h3>
<div class="section" id="xy-4-1-system-documentation">
<h4>XY.4.1 System documentation</h4>
<div class="section" id="xy-4-1-1-implementation-defined-options">
<h5>XY.4.1.1 Implementation-defined options</h5>
<p>No additional options.</p>
</div>
<div class="section" id="xy-4-1-2-ambiguous-conditions">
<h5>XY.4.1.2 Ambiguous conditions</h5>
<ul class="simple">
<li>An empty recognizer stack.</li>
<li>Changing the content of the parsed string during
parsing.</li>
</ul>
</div>
</div>
<div class="section" id="xy-4-2-program-documentation">
<h4>XY.4.2 Program documentation</h4>
<ul class="simple">
<li>No additional dependencies.</li>
</ul>
</div>
</div>
<div class="section" id="xy-5-compliance-and-labelling">
<h3>XY.5 Compliance and labelling</h3>
<p>The phrase &quot;Providing the Recognizer word set&quot; shall be appended
to the label of any Standard System that provides all of the
Recognizer word set.</p>
</div>
<div class="section" id="xy-6-glossary">
<h3>XY.6 Glossary</h3>
<div class="section" id="xy-6-1-recognizer-words">
<h4>XY.6.1 Recognizer words</h4>
<dl class="docutils">
<dt>DO-RECOGNIZER ( addr len -- i*x R:FOO | R:FAIL ) RECOGNIZER</dt>
<dd><p class="first">Apply the string at &quot;addr/len&quot; to the elements of the recognizer
stack. Terminate the iteration if either a recognizer returns
a information token that is different from <tt class="docutils literal">R:FAIL</tt> or the
stack is exhausted. In this case, return <tt class="docutils literal">R:FAIL</tt>, otherwise
<tt class="docutils literal">R:FOO</tt>.</p>
<p>&quot;i*x&quot; is the result of the parsing word. It may be on other locations
than the data stack. In this case the stack diagram should be read
accordingly.</p>
<p class="last">There is an ambiguous condition if the recognizer stack is empty.</p>
</dd>
<dt>GET-RECOGNIZERS ( -- rec-n .. rec-1 n ) RECOGNIZER</dt>
<dd><p class="first">Return the execution tokens <tt class="docutils literal"><span class="pre">rec-1</span> .. <span class="pre">rec-n</span></tt> of the parsing
words in the recognizer stack. <tt class="docutils literal"><span class="pre">rec-1</span></tt> identifies the recognizer
that is called first and <tt class="docutils literal"><span class="pre">rec-n</span></tt> the word that is called last.</p>
<p class="last">The recognizer stack is unaffected.</p>
</dd>
<dt>MARKER ( &quot;&lt;spaces&gt;name&quot; -- ) RECOGNIZER</dt>
<dd>Extend <tt class="docutils literal">MARKER</tt> to include the current recognizer stack in the state
preservation.</dd>
<dt>R:FAIL ( -- R:FAIL ) RECOGNIZER</dt>
<dd><p class="first">A constant cell sized information token with two uses: first it
is used to deliver the information that a specific recognizer
could not deal with the string passed to it. Second it is a
predefined information token whose elements are used
when no recognizer from the recognizer stack could handle the
passed string. These methods provide the system error actions.</p>
<p class="last">The actual numeric value is system dependent and has no
predictable value.</p>
</dd>
<dt>RECOGNIZER: ( XT-INTERPRET XT-COMPILE XT-POSTPONE &quot;&lt;spaces&gt;name&quot; -- ) RECOGNIZER</dt>
<dd><p class="first">Skip leading space delimiters. Parse name delimited by a space. Create
a recognizer information token &quot;name&quot; with the three execution tokens. The
implementation is system dependent.</p>
<p class="last">The words for XT-INTERPRET, XT-COMPILE and XT-POSTPONE are called with
the parsed data that the associated parsing word of the recognizer
returned. The information token itself is consumed by the interpreter.</p>
</dd>
<dt>SET-RECOGNIZERS ( rec-n .. rec-1 n -- ) RECOGNIZER</dt>
<dd>Set the recognizer stack to the recognizers identified by
the execution tokens of their parsing words <tt class="docutils literal"><span class="pre">rec-n</span> .. <span class="pre">rec-1</span></tt>.
<tt class="docutils literal"><span class="pre">rec-1</span></tt> will be the parsing word of the recognizer that is called
first, <tt class="docutils literal"><span class="pre">rec-n</span></tt> will be the last one. If n is not a positive number,
an ambiguous condition is met. A minimum recognizer stack shall include
the words for dealing with the dictionary and integer numbers.</dd>
</dl>
</div>
</div>
<div class="section" id="xy-7-reference-implementation">
<h3>XY.7 Reference Implementation</h3>
<p>The code has as little as possible dependencies (basically
only CORE). The implementations in gforth and amforth differ
and use highly system specific strategies. The code has been
tested on gforth 0.7.0.</p>
<pre class="code forth literal-block">
<span class="comment single">\ create a simple 3 element structure
</span><span class="keyword namespace">:</span> <span class="name class">RECOGNIZER:</span> <span class="comment single">( XT-INTERPRET XT-COMPILE XT-POSTPONE &quot;&lt;spaces&gt;name&quot; -- )</span>
   <span class="keyword">CREATE SWAP ROT , , ,
;
</span>
<span class="comment single">\ system failure recognizer
</span><span class="keyword">:NONAME </span><span class="literal number integer">-13</span> <span class="keyword">THROW ; DUP DUP </span><span class="name decorator">RECOGNIZER: R:FAIL
</span>
<span class="comment single">\ helper words to decode the data structure created by
\ RECOGNIZER: The knowledge they represent is used inside
\ POSTPONE and the text interpreter only.
</span><span class="keyword namespace">:</span> <span class="name class">_R&gt;POST</span> <span class="comment single">( R:FOO -- XT-POSTPONE )</span> <span class="keyword">CELL+ CELL+ &#64; ;
</span><span class="keyword namespace">:</span> <span class="name class">_R&gt;COMP</span> <span class="comment single">( R:FOO -- XT-COMPILE  )</span>       <span class="keyword">CELL+ &#64; ;
</span><span class="keyword namespace">:</span> <span class="name class">_R&gt;INT</span>  <span class="comment single">( R:FOO -- XT-INTERPRET)</span>             <span class="keyword">&#64; ;
</span>
<span class="comment single">\ contains the recognizer stack data
\ first cell is the current depth.
</span><span class="literal number integer">10</span> <span class="keyword">CELLS </span><span class="keyword namespace">BUFFER:</span> <span class="name class">rec-data</span>
<span class="literal number integer">0</span> <span class="name function">rec-data</span> <span class="keyword">! </span><span class="comment single">\ empty stack
</span>
<span class="keyword namespace">:</span> <span class="name class">SET-RECOGNIZERS</span> <span class="comment single">( rec-n .. rec-1 n -- )</span>
   <span class="keyword">DUP </span><span class="name function">rec-data</span> <span class="keyword">!
</span>   <span class="keyword">BEGIN
</span>     <span class="keyword">DUP
</span>   <span class="keyword">WHILE
</span>     <span class="keyword">DUP CELLS </span><span class="name function">rec-data</span> <span class="keyword">+
</span>     <span class="keyword">ROT SWAP ! 1-
</span>   <span class="keyword">REPEAT DROP
;
</span>
<span class="keyword namespace">:</span> <span class="name class">GET-RECOGNIZERS</span> <span class="comment single">( -- rec-n .. rec-1 n )</span>
   <span class="name function">rec-data</span> <span class="keyword">&#64; </span><span class="name function">rec-data</span>
   <span class="keyword">BEGIN
</span>     <span class="keyword">CELL+ OVER
</span>   <span class="keyword">WHILE
</span>     <span class="keyword">DUP &#64; ROT 1- ROT
</span>   <span class="keyword">REPEAT 2DROP
</span>   <span class="name function">rec-data</span> <span class="keyword">&#64;
;
</span>
<span class="keyword namespace">:</span> <span class="name class">DO-RECOGNIZER</span>   <span class="comment single">( addr len -- i*x R:FOO | R:FAIL )</span>
    <span class="name function">rec-data</span> <span class="keyword">&#64;
</span>    <span class="keyword">BEGIN
</span>      <span class="keyword">DUP
</span>    <span class="keyword">WHILE
</span>      <span class="keyword">DUP CELLS </span><span class="name function">rec-data</span> <span class="keyword">+ &#64;
</span>      <span class="keyword">2OVER 2&gt;R SWAP 1- &gt;R
</span>      <span class="keyword">EXECUTE DUP </span><span class="name decorator">R:FAIL </span><span class="name function">&lt;&gt;</span> <span class="keyword">IF R&gt; DROP 2R&gt; 2DROP EXIT THEN DROP
</span>      <span class="keyword">R&gt; 2R&gt; ROT
</span>    <span class="keyword">REPEAT
</span>    <span class="keyword">DROP 2DROP </span><span class="name decorator">R:FAIL
</span><span class="keyword">;</span>
</pre>
<p><tt class="docutils literal">POSTPONE</tt> is outside the Forth interpreter:</p>
<pre class="code forth literal-block">
<span class="keyword namespace">:</span> <span class="name class">POSTPONE</span> <span class="comment single">(  &quot;&lt;spaces&gt;name&quot; -- )</span>
  <span class="keyword">PARSE-NAME </span><span class="name decorator">DO-RECOGNIZER
</span>  <span class="name function">_R&gt;POST</span>    <span class="comment single">\ get the XT-POSTPONE from R:FOO
</span>  <span class="keyword">EXECUTE
; IMMEDIATE</span>
</pre>
</div>
</div>
<div class="section" id="a-xy-informal-appendix">
<h2>A.XY Informal Appendix</h2>
<div class="section" id="a-xy-1-forth-text-interpreter">
<h3>A.XY.1 Forth Text Interpreter</h3>
<p>The Forth text interpreter turns into a generic tool that is
capable to deal with any data type. It maintains <tt class="docutils literal">STATE</tt>
and calls the data processing methods according to it.</p>
<pre class="code forth literal-block">
<span class="keyword namespace">:</span> <span class="name class">INTERPRET</span>
  <span class="keyword">BEGIN
</span>    <span class="keyword">PARSE-NAME ?DUP IF DROP EXIT THEN </span><span class="comment single">\ no more words?
</span>    <span class="name decorator">DO-RECOGNIZER </span><span class="comment single">( addr len -- i*x R:FOO | R:FAIL)</span>
    <span class="keyword">STATE &#64; IF </span><span class="name function">_R&gt;COMP</span> <span class="keyword">ELSE </span><span class="name function">_R&gt;INT</span> <span class="keyword">THEN </span><span class="comment single">\ get the right XT from R:*
</span>    <span class="keyword">EXECUTE </span><span class="comment single">\ do the action.
</span>    <span class="name function">?STACK</span>  <span class="comment single">\ simple housekeeping
</span>  <span class="keyword">AGAIN
;</span>
</pre>
</div>
<div class="section" id="a-xy-2-example-recognizer">
<h3>A.XY.2 Example Recognizer</h3>
<p>The first example looks up the dictionary for the word
and returns the execution token and the header flags if
found. The data processing is the usual interpret/compile
action. The Compile actions checks for immediacy and act
accordingly. A portable postpone action is not possible.
Amforth and gforth do it in a system specific way.</p>
<pre class="code forth literal-block">
<span class="comment single">\ find-name is close to FIND. amforth specific.
</span><span class="literal number integer">256</span> <span class="keyword namespace">BUFFER:</span> <span class="name class">find-name-buf</span>
<span class="keyword namespace">:</span> <span class="name class">place</span> <span class="comment single">( c-addr1 u c-addr2 )</span> <span class="keyword">2DUP C! CHAR+ SWAP MOVE ;
</span><span class="keyword namespace">:</span> <span class="name class">find-name</span> <span class="comment single">( addr len -- xt +/-1 | 0 )</span>
    <span class="name function">find-name-buf</span> <span class="name function">place</span> <span class="name function">find-name-buf</span>
    <span class="keyword">FIND DUP 0= IF NIP THEN ;
</span>
<span class="keyword namespace">:</span> <span class="name class">immediate?</span> <span class="comment single">( flags -- true|false )</span> <span class="keyword">0&gt; ;
:NONAME </span><span class="comment single">( i*x XT flags -- j*y )</span>  <span class="comment single">\ INTERPRET
</span>  <span class="keyword">DROP EXECUTE ;
:NONAME </span><span class="comment single">( XT flags -- )</span>          <span class="comment single">\ COMPILE
</span>  <span class="name function">immediate?</span> <span class="keyword">IF COMPILE, ELSE EXECUTE THEN ;
:NONAME </span><span class="comment single">( XT flags -- )</span>          <span class="comment single">\ POSTPONE
</span>  <span class="name function">immediate?</span> <span class="keyword">IF COMPILE, ELSE POSTPONE LITERAL POSTPONE COMPILE, THEN ;
</span><span class="name decorator">RECOGNIZER: </span><span class="name function">R:WORD</span>

<span class="keyword namespace">:</span> <span class="name class">REC:WORD</span> <span class="comment single">( addr len -- XT flags R:WORD | R:FAIL )</span>
   <span class="name constant">find-name </span><span class="comment single">( addr len -- XT flags | 0 )</span>
   <span class="keyword">?DUP IF </span><span class="name function">R:WORD</span> <span class="keyword">ELSE </span><span class="name decorator">R:FAIL </span><span class="keyword">THEN ;
</span>
<span class="comment single">\ prepend the find recognizer to the recognizer stack
</span><span class="name function">GET-RECOGNIZERS</span> <span class="name function">'</span> <span class="name function">REC:FIND</span> <span class="keyword">SWAP 1+ </span><span class="name function">SET-RECOGNIZERS</span>
</pre>
<p>The second example deals with floating point numbers. The
interpret action is a do-nothing since there is nothing
that has to be done in addition to what the parsing word
already did. The compile action takes the floating point
number from the FP stack and compiles it to the dictionary.
Postponing numbers is not defined, thus the postpone
action here is printing the number and throwing an
exception.</p>
<pre class="code forth literal-block">
<span class="keyword">:NONAME ; </span>                  <span class="comment single">( -- )</span> <span class="name function">(F:</span> <span class="name function">f</span> <span class="name function">--</span> <span class="name function">f)</span> <span class="comment single">\ INTERPRET
</span><span class="keyword">:NONAME POSTPONE FLITERAL ; </span><span class="comment single">( -- )</span> <span class="name function">(F:</span> <span class="name function">f</span> <span class="name function">--</span> <span class="name function">)</span>  <span class="comment single">\ COMPILE
</span><span class="keyword">:NONAME FS. </span><span class="literal number integer">-48</span> <span class="keyword">THROW ; </span>    <span class="comment single">( -- )</span> <span class="name function">(F:</span> <span class="name function">f</span> <span class="name function">--</span> <span class="name function">)</span>  <span class="comment single">\ POSTPONE
</span><span class="name decorator">RECOGNIZER: </span><span class="name function">R:FLOAT</span>

<span class="keyword namespace">:</span> <span class="name class">REC:FLOAT</span> <span class="comment single">( addr len -- (F: -- f )</span> <span class="name function">R:FLOAT</span> <span class="name function">|</span> <span class="name decorator">R:FAIL </span><span class="name function">)</span>
  <span class="keyword">&gt;FLOAT IF </span><span class="name function">R:FLOAT</span> <span class="keyword">ELSE </span><span class="name decorator">R:FAIL </span><span class="keyword">THEN ;
</span>
<span class="comment single">\ append the float recognizer to the recognizer stack
</span><span class="name function">'</span> <span class="name function">REC:FLOAT</span> <span class="name function">GET-RECOGNIZERS</span> <span class="keyword">1+ </span><span class="name function">SET-RECOGNIZERS</span>
</pre>
</div>
</div>
</div>
<div class="section" id="experience">
<h1>Experience</h1>
<p>First ideas to dynamically extend the Forth text interpreter
were published in 2005 at comp.lang.forth by Josh Fuller and J Thomas:
<a class="reference external" href="https://web.archive.org/web/20160328150143/http://compgroups.net/comp.lang.forth/additional-recognizers/734676">Additional Recognizers?</a></p>
<p>A specific solution to deal with number prefixes was
roughly sketched by Anton Ertl at comp.lang.forth in 2007 with
<a class="reference external" href="https://web.archive.org/web/20160328150143/https://groups.google.com/forum/#!msg/comp.lang.forth/r7Vp3w1xNus/Wre1BaKeCvcJ">https://groups.google.com/forum/#!msg/comp.lang.forth/r7Vp3w1xNus/Wre1BaKeCvcJ</a></p>
<p>There are a number of specific solutions that can at least partly be seen
as recognizers in various Forth's:</p>
<ul class="simple">
<li>prefix-detection in ciforth</li>
<li>W32Forth uses its &quot;chain&quot; concept to achieve similar effects.</li>
<li>various commercial Forth's seem to have ways to extent the
interpreter.</li>
</ul>
<p>A first generic recognizer concept was implemented in amforth
version 4.3 (May 2011). The design presented in this RFD is
implemented with version 5.3 (May 2014). gforth has
recognizers since 2012, the ones described here since June
2014.</p>
<p>Existing recognizers cover a wide range of data formats
like floating point numbers and strings. Others mimic the
back-tick syntax used in many Unix shells to execute OS
sub-process. A recognizer is used to implement OO
notations.</p>
<p>Most of the small words that constitute a recognizer don't
need a name actually since only their execution tokens are
used. For the major words a naming convention is suggested:
<tt class="docutils literal"><span class="pre">REC:&lt;name&gt;</span></tt> for the parsing word of the recognizer
&quot;name&quot;, and <tt class="docutils literal"><span class="pre">R:&lt;name&gt;</span></tt> for the information token word
created with <tt class="docutils literal">RECOGNIZER:</tt> for the data type &quot;name&quot;.</p>
<p>There is no <tt class="docutils literal">REC:FAIL</tt> that would be the companion of
the system provided <tt class="docutils literal">R:FAIL</tt>. It's simply</p>
<pre class="code forth literal-block">
<span class="keyword namespace">:</span> <span class="name class">REC:FAIL</span> <span class="comment single">( addr len -- R:FAIL )</span>
  <span class="keyword">2DROP </span><span class="name decorator">R:FAIL </span><span class="keyword">;</span>
</pre>
<p>That way, <tt class="docutils literal">REC:FAIL</tt> can be seen as the parsing word of
the recognizer that is always present as the last one in the
recognizer stack and that cannot be deleted.</p>
<p>A Forth system that uses recognizers in the core
has words for numbers and dictionary look-ups. These
recognizers are useful for other data formats and use
cases as well. They shall be named identically as shown
in the table:</p>
<table border="1" class="docutils">
<colgroup>
<col width="17%"/>
<col width="41%"/>
<col width="42%"/>
</colgroup>
<tbody valign="top">
<tr><td>Name</td>
<td>Stack items</td>
<td>Comment</td>
</tr>
<tr><td><tt class="docutils literal">R:NUM</tt></td>
<td><tt class="docutils literal">( <span class="pre">--</span> n R:NUM)</tt></td>
<td>single cell numbers, based
on <tt class="docutils literal">&gt;NUMBER</tt></td>
</tr>
<tr><td><tt class="docutils literal">R:DNUM</tt></td>
<td><tt class="docutils literal">( <span class="pre">--</span> d R:DNUM)</tt></td>
<td>double cell numbers, based
on <tt class="docutils literal">&gt;NUMBER</tt></td>
</tr>
<tr><td><tt class="docutils literal">R:FLOAT</tt></td>
<td><tt class="docutils literal">( <span class="pre">--</span> f R:FLOAT)</tt></td>
<td>floating point numbers,
based on <tt class="docutils literal">&gt;FLOAT</tt></td>
</tr>
<tr><td><tt class="docutils literal">R:WORD</tt></td>
<td><tt class="docutils literal">( <span class="pre">--</span> XT flags R:WORD)</tt></td>
<td>words from the dictionary,
<tt class="docutils literal">FIND</tt></td>
</tr>
</tbody>
</table>
<p>The matching parsing words should be available as</p>
<table border="1" class="docutils">
<colgroup>
<col width="20%"/>
<col width="80%"/>
</colgroup>
<tbody valign="top">
<tr><td>Name</td>
<td>Stack effect</td>
</tr>
<tr><td><tt class="docutils literal">REC:NUM</tt></td>
<td><tt class="docutils literal">( addr len <span class="pre">--</span> n R:NUM&nbsp;&nbsp; | d R:DNUM | R:FAIL )</tt></td>
</tr>
<tr><td><tt class="docutils literal">REC:FLOAT</tt></td>
<td><tt class="docutils literal">( addr len <span class="pre">--</span> f R:FLOAT | R:FAIL )</tt></td>
</tr>
<tr><td><tt class="docutils literal">REC:WORD</tt></td>
<td><tt class="docutils literal">( addr len <span class="pre">--</span> XT flags R:WORD | R:FAIL )</tt></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="test-cases">
<h1>Test cases</h1>
<p>The hardest and ultimate test case is to use the interpreter
with recognizers enabled. Some parts can be tested separately,
however.</p>
<pre class="code forth literal-block">
<span class="name function">T{</span> <span class="name function">GET-RECOGNIZERS</span> <span class="name function">SET-RECOGNIZERS</span> <span class="name function">-&gt;</span> <span class="name function">}T</span>
<span class="name function">T{</span> <span class="name function">GET-RECOGNIZERS</span> <span class="name function">SET-RECOGNIZERS</span> <span class="name function">GET-RECOGNIZERS</span> <span class="name function">-&gt;</span> <span class="name function">GET-RECOGNIZERS</span> <span class="name function">}T</span>
<span class="name function">T{</span> <span class="literal string">s&quot;</span> <span class="literal string">unknown word</span><span class="name function">&quot;</span> <span class="name decorator">DO-RECOGNIZER </span> <span class="name function">-&gt;</span> <span class="name decorator">R:FAIL </span><span class="name function">}T</span>
</pre>
<p>The system provided recognizers, if available,
work as follows:</p>
<pre class="code forth literal-block">
<span class="name function">T{</span> <span class="literal string">s&quot;</span> <span class="literal string">1234</span><span class="name function">&quot;</span>  <span class="name decorator">DO-RECOGNIZER </span><span class="name function">-&gt;</span> <span class="literal number integer">1234</span>  <span class="name function">R:NUM</span>   <span class="name function">}T</span>
<span class="name function">T{</span> <span class="literal string">s&quot;</span> <span class="literal string">1234.</span><span class="name function">&quot;</span> <span class="name decorator">DO-RECOGNIZER </span><span class="name function">-&gt;</span> <span class="literal number integer">1234</span><span class="keyword">. </span><span class="name function">R:DNUM</span>  <span class="name function">}T</span>
<span class="name function">T{</span> <span class="literal string">s&quot;</span> <span class="literal string">1e3</span><span class="name function">&quot;</span>   <span class="name decorator">DO-RECOGNIZER </span><span class="name function">-&gt;</span>  <span class="literal number integer">1</span><span class="name function">e3</span>  <span class="name function">R:FLOAT</span> <span class="name function">}T</span>
<span class="name function">T{</span> <span class="literal string">s&quot;</span> <span class="literal string">DO-RECOGNIZER</span><span class="name function">&quot;</span> <span class="name decorator">DO-RECOGNIZER </span><span class="name function">-&gt;</span> <span class="name function">'</span> <span class="name decorator">DO-RECOGNIZER </span><span class="literal number integer">-1</span> <span class="name function">R:WORD</span> <span class="name function">}T</span>
</pre>
</div>
<hr class="docutils"/>
<div class="section" id="points-to-discuss">
<h1>Points To Discuss</h1>
<p>Provide words to create the system defaults in the
tradition of <tt class="docutils literal">FORTH</tt> and <tt class="docutils literal">ONLY</tt> for word lists?</p>
<p>What is the semantics of postponing data apart from
words from the dictionary?</p>
<pre class="code forth literal-block">
<span class="keyword">POSTPONE </span><span class="literal number integer">42</span>
<span class="keyword">POSTPONE </span><span class="name function">&quot;a</span> <span class="name function">string&quot;</span>
<span class="keyword">POSTPONE </span><span class="name function">`a</span> <span class="name function">system</span> <span class="name function">command`</span>
</pre>
</div>
<div class="section" id="change-history">
<h1>Change history</h1>
<blockquote>
<ul class="simple">
<li>2014-10-03 Version 1</li>
</ul>
</blockquote>
</div>
</div>
</body>
</html>
<!--
     FILE ARCHIVED ON 15:01:43 Mar 28, 2016 AND RETRIEVED FROM THE
     INTERNET ARCHIVE ON 11:25:19 Sep 21, 2020.
     JAVASCRIPT APPENDED BY WAYBACK MACHINE, COPYRIGHT INTERNET ARCHIVE.

     ALL OTHER CONTENT MAY ALSO BE PROTECTED BY COPYRIGHT (17 U.S.C.
     SECTION 108(a)(3)).
-->
<!--
playback timings (ms):
  exclusion.robots: 0.206
  esindex: 0.016
  LoadShardBlock: 354.344 (3)
  PetaboxLoader3.datanode: 477.292 (4)
  exclusion.robots.policy: 0.191
  RedisCDXSource: 199.663
  captures_list: 579.72
  load_resource: 260.239
  PetaboxLoader3.resolve: 87.552
  CDXLines.iter: 21.472 (3)
-->