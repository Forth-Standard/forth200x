<title>2s-Complement Wrap-Around Integers</title>

<h3>2s-Complement Wrap-Around Integers</h3>

<pre>
Problem

Many programs depend on 2s-complement representation of negative
integers (e.g., assuming that TRUE is -1), and on wraparound behaviour
on integer overflow, and should declare an environmental dependency on
these features.  These programs should become unconditionally standard
programs.

To my knowledge, all Forth systems provide these features and all
architectures developed since about 1970 support 2s-complement (this
includes Chuck Moore's chips), so other signed number representations
are now even less relevant than in the past (when they did not lead to
non-2s-complement Forth systems, either).


Solution

Negative integers are represented as 2s-complement numbers.

On integer overflow of single-cell addition (+ 1+ +! cell+ char+ etc.),
subtraction (- 1- negate abs), multiplication (* chars cells floats
etc.) 2* and d>s the result is the exact result modulo 2^n (for n-bit
cells) leading to wraparound behaviour for + and -; for overflow of d+
d- dnegate dabs m+, the result is the exact result modulo 2^(2*n).

Division by 0 and when the division result does not fit into the
result are still ambiguous conditions (some architectures produce
exceptions in these cases, others don't).

Not sure about F>S F>D.


Typical use

: within ( n a b -- f )
    over - >r - r> u< ;

Implementing this without relying on wrap-around arithmetics
is <a href="http://al.howardknight.net/msgid.cgi?ID=143257091900">complicated</a>.


Proposal

Remove permission for one's complement and sign-magnitude from 3.2.1.1.

Replace 3.2.2.2 with: In all integer arithmetic operations except
divisions, both overflow and underflow shall be ignored.  Replace the
second sentence with: The value returned when either overflow or
underflow occurs is:

for unsigned results, the exact result modulo 2^n

for signed results, and the exact result r, the number x in the range
2^(n-1)<=x<2^(n-1) that satisfies x congruent r (mod 2^n).

where n is the number of bits in the result.

(can we make this any more understandable without losing precision?).

Replace -32767 with -32768 in 3.1.3.2

(Any other places we have to look after?)


Reference implementation

Any current Forth system.


Test cases

T{ 0 invert -> -1 }T
T{ MAX-INT 1+ -> MIN-INT }T

More TBD.


Experience

Universally implemented and widely used.


Comments

Feedback to the proposal goes here.
</pre>



